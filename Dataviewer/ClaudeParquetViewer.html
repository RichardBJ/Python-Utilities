<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parquet File Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@9.0.0/Arrow.es5.min.js"></script>
    <style>
        #loading { display: none; }
        #error { color: red; display: none; }
        #log { font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".parquet">
    <div id="loading">Loading... <span id="progress"></span></div>
    <div id="error"></div>
    <canvas id="myChart"></canvas>
    <div id="log"></div>

    <script type="module">
        import * as Arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@9.0.0/Arrow.es2015.min.js';

        const fileInput = document.getElementById('fileInput');
        const loadingDiv = document.getElementById('loading');
        const progressSpan = document.getElementById('progress');
        const errorDiv = document.getElementById('error');
        const logDiv = document.getElementById('log');
        const ctx = document.getElementById('myChart').getContext('2d');
        let chart;

        function log(message) {
            console.log(message);
            logDiv.textContent += message + '\n';
        }

        function logError(error) {
            const errorMessage = error.stack || error.message || String(error);
            console.error(errorMessage);
            logDiv.textContent += 'ERROR: ' + errorMessage + '\n';
        }

        async function readFileChunked(file) {
            const chunkSize = 1024 * 1024; // 1MB chunks
            const chunks = [];
            let offset = 0;
            
            while (offset < file.size) {
                const chunk = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(new Uint8Array(e.target.result));
                    reader.onerror = reject;
                    const slice = file.slice(offset, offset + chunkSize);
                    reader.readAsArrayBuffer(slice);
                });
                chunks.push(chunk);
                offset += chunk.length;
                const progress = Math.round((offset / file.size) * 100);
                progressSpan.textContent = `${progress}%`;
            }

            return new Uint8Array(chunks.reduce((acc, val) => [...acc, ...val], []));
        }

        fileInput.addEventListener('change', async (event) => {
            try {
                loadingDiv.style.display = 'block';
                errorDiv.style.display = 'none';
                logDiv.textContent = '';
                
                log('File selected, reading file...');
                const file = event.target.files[0];
                const fileData = await readFileChunked(file);
                log(`File loaded, size: ${fileData.length} bytes`);

                log('Parsing Parquet file...');
                const table = await Arrow.tableFromIPC(fileData);
                log(`Parquet file parsed, schema: ${table.schema.fields.map(f => f.name).join(', ')}`);

                const data = table.toArray();
                log(`Data converted to array, length: ${data.length}`);

                if (!data.length || !data[0].hasOwnProperty('x') || !data[0].hasOwnProperty('y1') || !data[0].hasOwnProperty('y2')) {
                    throw new Error("The Parquet file doesn't contain the expected columns (x, y1, y2)");
                }

                const xValues = data.slice(0, 1000).map(row => row['x']);
                const y1Values = data.slice(0, 1000).map(row => row['y1']);
                const y2Values = data.slice(0, 1000).map(row => row['y2']);

                if (chart) {
                    chart.destroy();
                }

                log('Creating chart...');
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: xValues,
                        datasets: [
                            {
                                label: 'Y1',
                                data: y1Values,
                                borderColor: 'rgb(75, 192, 192)',
                                tension: 0.1
                            },
                            {
                                label: 'Y2',
                                data: y2Values,
                                borderColor: 'rgb(255, 99, 132)',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Parquet File Graph (First 1000 Rows)'
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'X Values'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Y Values'
                                }
                            }
                        }
                    }
                });

                log('Chart created successfully');
            } catch (error) {
                logError(error);
                errorDiv.textContent = `Error: ${error.message || 'An unknown error occurred'}`;
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
            }
        });
    </script>
</body>
</html>